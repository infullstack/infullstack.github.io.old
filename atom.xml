<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ray</title>
  
  <subtitle>Ray&#39;s blog.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://infullstack.github.io/"/>
  <updated>2018-09-06T02:36:12.765Z</updated>
  <id>https://infullstack.github.io/</id>
  
  <author>
    <name>Ray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kylin智能构建工具</title>
    <link href="https://infullstack.github.io/kylin-cube-build-tools.html"/>
    <id>https://infullstack.github.io/kylin-cube-build-tools.html</id>
    <published>2018-09-06T02:32:25.000Z</published>
    <updated>2018-09-06T02:36:12.765Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kylin" scheme="https://infullstack.github.io/tags/kylin/"/>
    
      <category term="构建工具" scheme="https://infullstack.github.io/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="cube" scheme="https://infullstack.github.io/tags/cube/"/>
    
      <category term="多维" scheme="https://infullstack.github.io/tags/%E5%A4%9A%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>我的博客史</title>
    <link href="https://infullstack.github.io/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8F%B2.html"/>
    <id>https://infullstack.github.io/我的博客史.html</id>
    <published>2018-01-19T05:40:42.000Z</published>
    <updated>2018-03-02T05:41:28.881Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1473186505569-9c61870c11f9?auto=format&amp;fit=crop&amp;w=1650&amp;q=80" alt=""></p><p>说起我的博客历史，大概分为6段小历史，首先得从2010年说起。</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>2010年，从大学毕业一开始就已经开始了我的博客生涯。当时第一个博客还是在Iteye上，当时的博客地址是：<a href="http://yanleijava.iteye.com/" target="_blank" rel="noopener">帅的被神砍</a>，寥寥写了几篇技术文章。当时每天必上的技术网站就是Iteye，关注创始人的robbin的动态，然而iteye已经被csdn收购，robbin也已经成了丁香园的CTO</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>做为程序员，最关注的就是开源，所以iteye的衰弱，让我从iteye转到了oschina，转发或原创了一些技术文章。当时比较开始的是，一有用到的精简代码，就会在上面分享出来。<a href="https://www.oschina.net/code/list_by_user?id=107039" target="_blank" rel="noopener">磊神Ray分享的代码列表(32)</a>，因为当时分享的代码在开源中国首页，每天都有很多人看和讨论。</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>不满足与在技术网站上建博客，于是开始自建博客，买的第一个域名是<a href="iyanlei.com">iyanlei.com</a>，这个博客也一直保留了下来。用的typecho，写了不少typecho主题。也分享了一些typecho的技术文章，如typecho pjax的实现。</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>工作的原因，很久没更新iyanlei.com，同时觉得域名不好看，于是购买了misray.com，用的wordpress，做了个主题，写了一些生活类的文章。</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>又开始专注技术了，入了infullstack.com，也分享了不少技术文章。</p><h4 id="终"><a href="#终" class="headerlink" title="终"></a>终</h4><p>最终回归到了misray.com，把以前所有值得收藏的文章，统一了一下，用github+hexo，继续着我的博客之路。</p><p>总结了一些博客之路的心得：简单的就是最美的，内容为王。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1473186505569-9c61870c11f9?auto=format&amp;amp;fit=crop&amp;amp;w=1650&amp;amp;q=80&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;说起我的博
      
    
    </summary>
    
    
      <category term="blog" scheme="https://infullstack.github.io/tags/blog/"/>
    
      <category term="博客" scheme="https://infullstack.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="历史" scheme="https://infullstack.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>ycsb使用指南</title>
    <link href="https://infullstack.github.io/ycsb%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html"/>
    <id>https://infullstack.github.io/ycsb使用指南.html</id>
    <published>2018-01-17T12:04:23.000Z</published>
    <updated>2018-01-17T12:10:16.073Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>YCSB（Yahoo! Cloud Serving Benchmark）是雅虎开源的一款通用的性能测试工具。<br>通过这个工具我们可以对各类NoSQL产品进行相关的性能测试，包括：PNUTS、BigTable 、HBase、Hypertable、Azure、Cassandra、CouchDB、Voldemort、MongoDb、Dynomite。</p><p>YCSB与HBase自带的性能测试工具（PerformanceEvaluation）相比，好处在于：</p><ul><li>扩展：进行性能测试的客户端不仅仅只是HBase一款产品，而且可以是HBase不同的版本。</li><li>灵活：进行性能测试的时候，可以选择进行测试的方式：read+write，read+scan等，还可以选择不同操作的频度与选取Key的方式。</li><li>监控：进行性能测试的时候，可以实时显示测试进行的进度：</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载ycsb 0.6压缩包，解压即可<br><a href="https://github.com/brianfrankcooper/YCSB/releases/download/0.6.0/ycsb-0.6.0.tar.gz" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/releases/download/0.6.0/ycsb-0.6.0.tar.gz</a></p><p>注：执行ycsb时，如果报python argparse模块异常，因为python版本低，需要安装python argparse模块 ，解压进入执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>创建Hbase表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n_splits = 200 </span><br><span class="line">create &apos;usertable&apos;, &apos;family&apos;, &#123;SPLITS =&gt; (1..n_splits).map &#123;|i| &quot;user#&#123;1000+i*(9999-1000)/n_splits&#125;&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>Ycsb的执行配置在workload文件下，可以参考workloada和workload_template配置文件</p><ul><li><p>Load配置<br>Workload文件夹下新建workload_load文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#记录数</span><br><span class="line">recordcount=10000000</span><br><span class="line">#操作记录数</span><br><span class="line">operationcount=10000000</span><br><span class="line"># 测试类</span><br><span class="line">workload=com.yahoo.ycsb.workloads.CoreWorkload</span><br><span class="line">readallfields=true</span><br><span class="line"># read比例</span><br><span class="line">readproportion=0</span><br><span class="line"># update比例</span><br><span class="line">updateproportion=0</span><br><span class="line"># scan比例</span><br><span class="line">scanproportion=0</span><br><span class="line"># Load比例</span><br><span class="line">insertproportion=1</span><br><span class="line">requestdistribution=zipfian</span><br><span class="line"># The number of fields in a record</span><br><span class="line">fieldcount=10</span><br><span class="line"># The size of each field (in bytes)</span><br><span class="line">fieldlength=100</span><br><span class="line"># hbase表</span><br><span class="line">table=usertable</span><br><span class="line">columnfamily=family</span><br></pre></td></tr></table></figure></li><li><p>Scan配置<br>Workload文件夹下新建workload_scan文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">recordcount=10000000</span><br><span class="line">operationcount=10000000</span><br><span class="line">workload=com.yahoo.ycsb.workloads.CoreWorkload</span><br><span class="line">readallfields=true</span><br><span class="line">readproportion=0</span><br><span class="line">updateproportion=0</span><br><span class="line">scanproportion=1</span><br><span class="line">insertproportion=0</span><br><span class="line">requestdistribution=zipfian</span><br><span class="line">table=usertable</span><br><span class="line">columnfamily=family</span><br><span class="line">#必填</span><br><span class="line">hbase.usepagefilter=false</span><br></pre></td></tr></table></figure></li><li><p>Read配置<br>Workload文件夹下新建workload_read文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">recordcount=10000000</span><br><span class="line">operationcount=10000000</span><br><span class="line">workload=com.yahoo.ycsb.workloads.CoreWorkload</span><br><span class="line">readallfields=true</span><br><span class="line">readproportion=1</span><br><span class="line">updateproportion=0</span><br><span class="line">scanproportion=0</span><br><span class="line">insertproportion=0</span><br><span class="line">requestdistribution=zipfian</span><br><span class="line">table=usertable</span><br><span class="line">columnfamily=family</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>Load</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/ycsb load hbase098 -P workloads/workload_load -cp hbase098-binding/conf –threads 100</span><br></pre></td></tr></table></figure></li><li><p>Scan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/ycsb load hbase098 -P workloads/workload_scan -cp hbase098-binding/conf –threads 100</span><br></pre></td></tr></table></figure></li><li><p>Read</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/ycsb load hbase098 -P workloads/workload_read -cp hbase098-binding/conf –threads 100</span><br></pre></td></tr></table></figure></li></ul><p>测试的时候可以在集群的节点上启多个客户端执行ycsb测试，如：Load测试，集群5个节点，各启动10个客户端，每个客户端启动100个线程，总共是5000个线程执行Load</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;YCSB（Yahoo! Cloud Serving Benchmark）是雅虎开源的一款通用的性能测试工具。&lt;br&gt;通过这个工具我们可以对各
      
    
    </summary>
    
    
      <category term="性能" scheme="https://infullstack.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="hbase" scheme="https://infullstack.github.io/tags/hbase/"/>
    
      <category term="ycsb" scheme="https://infullstack.github.io/tags/ycsb/"/>
    
      <category term="测试" scheme="https://infullstack.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>kerberos定时登录设置</title>
    <link href="https://infullstack.github.io/kerberos%E5%AE%9A%E6%97%B6%E7%99%BB%E5%BD%95%E8%AE%BE%E7%BD%AE.html"/>
    <id>https://infullstack.github.io/kerberos定时登录设置.html</id>
    <published>2018-01-16T13:53:25.000Z</published>
    <updated>2018-01-16T14:07:25.215Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-增加Crontab定时任务"><a href="#1-增加Crontab定时任务" class="headerlink" title="1. 增加Crontab定时任务"></a>1. 增加Crontab定时任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 定时每小时20分执行一次，同时输出执行日志</span><br><span class="line">20 * * * * sh /user/kylin/kerberos_init.sh &gt;&gt; /user/kylin/kerberos_init.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h5 id="2-脚本"><a href="#2-脚本" class="headerlink" title="2.脚本"></a>2.脚本</h5><ul><li>kerberos_init.sh脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## 引入Fusioninght客户端变量，CDH不需要这步</span><br><span class="line">source /opt/hadoop_client/bigdata_env</span><br><span class="line">## 引入变量</span><br><span class="line">source /user/root/krb5.sh</span><br><span class="line">## 登录kerberos</span><br><span class="line">kinit kylin &lt;&lt;EOF</span><br><span class="line">kylin</span><br><span class="line">EOF</span><br><span class="line">klist</span><br></pre></td></tr></table></figure><ul><li>krb5.sh脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># 设置kerberos认证缓存目录</span><br><span class="line">export KRB5CCNAME=/user/kylin/krb5_cache</span><br></pre></td></tr></table></figure><h5 id="3-环境变量-可选"><a href="#3-环境变量-可选" class="headerlink" title="3. 环境变量(可选)"></a>3. 环境变量(可选)</h5><ul><li>增加KRB5CCNAME变量到用户环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 编辑~/.bashrc增加一行</span><br><span class="line">source /user/root/krb5.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;1-增加Crontab定时任务&quot;&gt;&lt;a href=&quot;#1-增加Crontab定时任务&quot; class=&quot;headerlink&quot; title=&quot;1. 增加Crontab定时任务&quot;&gt;&lt;/a&gt;1. 增加Crontab定时任务&lt;/h5&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
    
      <category term="linux" scheme="https://infullstack.github.io/tags/linux/"/>
    
      <category term="kerberos" scheme="https://infullstack.github.io/tags/kerberos/"/>
    
      <category term="crontab" scheme="https://infullstack.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://infullstack.github.io/hello-hexo.html"/>
    <id>https://infullstack.github.io/hello-hexo.html</id>
    <published>2017-12-27T02:21:00.000Z</published>
    <updated>2018-01-04T14:33:17.079Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1451481454041-104482d8e284?auto=format&amp;fit=crop&amp;w=2550&amp;q=80" alt=""></p><p>已经很长时间没有管理博客了，在2018快要到来之前，决心整理下了，在github上部署了Hexo，选取了以前各个博客系统的主要文章，同步到了hexo，以前的文章用markdown格式在文章迁移上，优势就体现出来了。只不过评论就不同步了。</p><p>纯静态化、可以快速部署在github或coding、高效、易于扩展，最重要的是轻量简洁，同时还不需要管理服务器，不用再担心服务器故障，在有文章发布时，push到github即可。</p><p>Hexo真是一个非常美好的博客系统。</p><h2 id="我的Hexo配置"><a href="#我的Hexo配置" class="headerlink" title="我的Hexo配置"></a>我的Hexo配置</h2><p>theme: <a href="https://github.com/probberechts/cactus-dark" target="_blank" rel="noopener">cactus-dark</a><br>comment: <a href="https://valine.js.org/#/?id=valine" target="_blank" rel="noopener">valine</a></p><p>部署hexo和域名绑定过程参考：<a href="https://www.cnblogs.com/ldnh/archive/2017/10/11/7651840.html" target="_blank" rel="noopener">Mac上搭建基于Github的Hexo博客</a></p><h2 id="new-begin"><a href="#new-begin" class="headerlink" title="new begin"></a>new begin</h2><p>以前零碎搭了多个域名和博客，这次统一入口，算一个新的开始吧。</p><p>enjoy it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://images.unsplash.com/photo-1451481454041-104482d8e284?auto=format&amp;amp;fit=crop&amp;amp;w=2550&amp;amp;q=80&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;已经很长时
      
    
    </summary>
    
      <category term="杂物间" scheme="https://infullstack.github.io/categories/%E6%9D%82%E7%89%A9%E9%97%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据技术文章索引</title>
    <link href="https://infullstack.github.io/bigdata-tech-post-index.html"/>
    <id>https://infullstack.github.io/bigdata-tech-post-index.html</id>
    <published>2017-07-05T09:00:44.000Z</published>
    <updated>2018-01-04T13:53:30.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/filip-gielda-94858.jpg?imageView2/1/w/2400/h/800/" alt=""></p><h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><ul><li><a href="http://www.infoq.com/cn/articles/in-depth-analysis-of-parquet-column-storage-format" target="_blank" rel="noopener">深入分析Parquet列式存储格式</a></li><li><a href="http://dongxicheng.org/mapreduce-nextgen/columnar-storage-parquet-and-orc/" target="_blank" rel="noopener">大数据开源列式存储引擎Parquet和ORC</a></li><li><a href="https://www.iteblog.com/archives/1014.html" target="_blank" rel="noopener">Hive:ORC File Format存储格式详解</a></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><ul><li><a href="http://www.uml.org.cn/sjjm/201309044.asp" target="_blank" rel="noopener">HDFS 原理、架构与特性介绍</a></li><li><a href="http://blog.csdn.net/weixuehao/article/details/16967485" target="_blank" rel="noopener">HDFS的运行原理</a></li><li><a href="http://www.it165.net/admin/html/201407/3465.html" target="_blank" rel="noopener">Namenode HA原理详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/25928166" target="_blank" rel="noopener">Apache Kudu 加速对频繁更新数据的分析</a></li><li><a href="http://www.leiphone.com/news/201610/rRTDqNk6lQrInqje.html" target="_blank" rel="noopener">基于内存的统一分布式存储系统 Alluxio 及其应用</a></li></ul><h2 id="计算引擎"><a href="#计算引擎" class="headerlink" title="计算引擎"></a>计算引擎</h2><ul><li><a href="http://blog.jobbole.com/84089/" target="_blank" rel="noopener">MapReduce框架详解</a></li><li><a href="http://langyu.iteye.com/blog/992916" target="_blank" rel="noopener">MapReduce:详解Shuffle过程</a></li><li><a href="http://blog.csdn.net/lovehuangjiaju/article/details/48634607" target="_blank" rel="noopener">Spark运行原理</a></li><li><a href="http://tech.meituan.com/spark-tuning-basic.html" target="_blank" rel="noopener">Spark性能优化指南</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-flink/" target="_blank" rel="noopener">新一代大数据处理引擎 Apache Flink</a></li><li><a href="http://shiyanjun.cn/archives/1508.html" target="_blank" rel="noopener">Apache Flink：特性、概念、组件栈、架构及原理分析</a></li></ul><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><ul><li><a href="http://shiyanjun.cn/archives/1002.html" target="_blank" rel="noopener">Hue安装配置实践</a></li><li><a href="http://www.cnblogs.com/smartloli/p/5191155.html" target="_blank" rel="noopener">Azkaban 作业调度</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><ul><li><a href="http://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">[HBase] LSM树 VS B+树</a></li><li><a href="https://yq.aliyun.com/articles/70467" target="_blank" rel="noopener">HBase在阿里的应用实践</a></li></ul><h2 id="SQL引擎"><a href="#SQL引擎" class="headerlink" title="SQL引擎"></a>SQL引擎</h2><ul><li><a href="http://www.csdn.net/article/2013-12-04/2817707-Impala-Big-Data-Engine" target="_blank" rel="noopener">Impala：新一代开源大数据分析引擎</a></li><li><a href="http://www.infoq.com/cn/articles/apache-kylin-algorithm/" target="_blank" rel="noopener">Apache Kylin的快速数据立方体算法——概述</a></li><li><a href="http://tech.meituan.com/presto.html" target="_blank" rel="noopener">Presto实现原理和美团的使用实践</a></li></ul><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><ul><li><a href="http://shiyanjun.cn/archives/1472.html" target="_blank" rel="noopener">Apache Storm内部原理分析</a></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><a href="http://tech.meituan.com/mq-design.html" target="_blank" rel="noopener">消息队列设计精要</a></li><li><a href="http://www.jasongj.com/2015/01/02/Kafka%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">Kafka深度解析</a></li><li><p><a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="noopener">Kafka文件存储机制那些事</a></p><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2></li><li><p><a href="https://my.oschina.net/leejun2005/blog/288136" target="_blank" rel="noopener">Flume NG 简介及配置实战</a></p></li><li><a href="http://shiyanjun.cn/archives/1497.html" target="_blank" rel="noopener">Flume日志收集分层架构应用实践</a></li><li><a href="http://student-lp.iteye.com/blog/2157983" target="_blank" rel="noopener">Sqoop详解</a></li><li><a href="http://tech.meituan.com/mt-log-system-arch.html" target="_blank" rel="noopener">基于Flume的美团日志收集系统(一)架构和设计</a></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li><a href="http://www.infoq.com/cn/articles/kylin-apache-in-meituan-olap-scenarios-practice" target="_blank" rel="noopener">Apache Kylin在美团数十亿数据OLAP场景下的实践</a></li><li><a href="http://tech.meituan.com/spark-in-meituan.html" target="_blank" rel="noopener">Spark在美团的实践</a></li><li><a href="http://mp.weixin.qq.com/s/OJdlpP62YWGmVnBWsfpVZw" target="_blank" rel="noopener">携程实时用户行为系统实践</a></li></ul><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><ul><li><a href="http://www.shaheng.me/blog/2015/06/elasticsearch--.html" target="_blank" rel="noopener">Elasticsearch架构原理</a></li><li><p><a href="http://solr-vs-elasticsearch.com/" target="_blank" rel="noopener">solr vs elasticsearch 功能比较</a></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-mahout/" target="_blank" rel="noopener">Apache Mahout 简介</a></p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="http://mp.weixin.qq.com/s/mO9Ht3pBlvDUFd-cUmz99w" target="_blank" rel="noopener">谷歌新发布的分布式数据库服务，是要打破CAP定理了吗？</a></li><li><a href="https://m.aliyun.com/yunqi/articles/67000?tk=7msDtByJNMqIx7H1CqaPNnPbyUQ36CfaBHCMB9l9R4w%3D" target="_blank" rel="noopener">分布式(hadoop)内核研发面试指南</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/filip-gielda-94858.jpg?imageView2/1/w/2400/h/800/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;存储格式&quot;&gt;&lt;a href=&quot;#存储格式&quot; c
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="https://infullstack.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="https://infullstack.github.io/tags/hadoop/"/>
    
      <category term="parquet" scheme="https://infullstack.github.io/tags/parquet/"/>
    
      <category term="hdfs" scheme="https://infullstack.github.io/tags/hdfs/"/>
    
      <category term="spark" scheme="https://infullstack.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>shell逐行读取文本的几种方法</title>
    <link href="https://infullstack.github.io/shell-row.html"/>
    <id>https://infullstack.github.io/shell-row.html</id>
    <published>2017-05-22T05:10:34.000Z</published>
    <updated>2018-01-04T13:59:04.964Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/andreas-ronningen-31469.jpg?imageView2/1/w/1980/h/900/" alt=""></p><p>经常会对文体文件进行逐行处理，在Shell里面如何获取每行数据，然后处理该行数据，最后读取下一行数据，循环处理．有多种解决方法如下：</p><h3 id="通过read命令完成．"><a href="#通过read命令完成．" class="headerlink" title="通过read命令完成．"></a>通过read命令完成．</h3><p>read命令接收标准输入，或其他文件描述符的输入，得到输入后，read命令将数据放入一个标准变量中．</p><p>利用read读取文件时，每次调用read命令都会读取文件中的”一行”文本．</p><p>当文件没有可读的行时，read命令将以非零状态退出．</p><p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat data.dat | while read line</span><br><span class="line">do</span><br><span class="line">   echo &quot;File:$&#123;line&#125;&quot;</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">while read line</span><br><span class="line">do </span><br><span class="line">    echo &quot;File:$&#123;line&#125;&quot;</span><br><span class="line">done &lt; data.dat</span><br></pre></td></tr></table></figure></p><p>2.使用awk命令完成</p><p>awk是一种优良的文本处理工具，提供了极其强大的功能．</p><p>利用awk读取文件中的每行数据，并且可以对每行数据做一些处理，还可以单独处理每行数据里的每列数据．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat data.dat | awk &apos;&#123;print $0&#125;&apos;</span><br><span class="line">cat data.dat | awk &apos;for(i=2;i&lt;NF;i++) &#123;printf $i&#125; printf &quot;\n&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>第1行代码输出data.dat里的每行数据，第2代码输出每行中从第2列之后的数据．</p><p>如果是单纯的数据或文本文件的按行读取和显示的话，使用awk命令比较方便．</p><p>3.使用for var in file 命令完成</p><p>for var in file　表示变量var在file中循环取值．取值的分隔符由$IFS确定．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for line in $(cat data.dat)</span><br><span class="line">do </span><br><span class="line">    echo &quot;File:$&#123;line&#125;&quot;</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">for line in `cat data.dat`</span><br><span class="line">do </span><br><span class="line">    echo &quot;File:$&#123;line&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果输入文本每行中没有空格，则line在输入文本中按换行符分隔符循环取值．</p><p>如果输入文本中包括空格或制表符，则不是换行读取，line在输入文本中按空格分隔符或制表符或换行符特环取值．</p><p>可以通过把IFS设置为换行符来达到逐行读取的功能．</p><p>IFS的默认值为：空白(包括：空格，制表符，换行符)．</p><h3 id="字符串split"><a href="#字符串split" class="headerlink" title="字符串split"></a>字符串split</h3><p>获取到每行的文本字符串，也许还会用到字符串的切分，可以使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmp_str=&quot;a,b,c&quot;</span><br><span class="line">table=($&#123;tmp_str//,/ &#125;)</span><br><span class="line">table_name=$&#123;table[1]&#125;</span><br><span class="line">cube_name=$&#123;table[0]&#125;</span><br><span class="line">echo $table_name $cube_name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/andreas-ronningen-31469.jpg?imageView2/1/w/1980/h/900/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;经常会对文体文件进行逐行处理，在Shell里面
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="https://infullstack.github.io/tags/shell/"/>
    
      <category term="逐行" scheme="https://infullstack.github.io/tags/%E9%80%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈2017NBA常规赛MVP</title>
    <link href="https://infullstack.github.io/2017-nba-mvp.html"/>
    <id>https://infullstack.github.io/2017-nba-mvp.html</id>
    <published>2017-04-07T09:17:23.000Z</published>
    <updated>2018-01-04T13:55:11.960Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/maxresdefault.jpg?imageView2/1/w/1980/h/900/" alt=""></p><p>16-17赛季常规赛接近尾声，西部季后赛球队名单和排名基本确定，反观东部，3-4名还在争夺，5/6/7/8/9还在激烈争夺。</p><p>常规赛MVP，这个赛季也是竞争相当激烈。</p><h2 id="MVP候选浅析"><a href="#MVP候选浅析" class="headerlink" title="MVP候选浅析"></a>MVP候选浅析</h2><h3 id="詹姆斯-哈登"><a href="#詹姆斯-哈登" class="headerlink" title="詹姆斯.哈登"></a>詹姆斯.哈登</h3><p>哈登场均29.1分8.1个篮板11.2次助攻，助攻居联盟第一，得分居联盟第二，火箭至今52胜25负，列西部第三，也是全联盟第三最佳战绩。</p><h3 id="韦斯特布鲁克"><a href="#韦斯特布鲁克" class="headerlink" title="韦斯特布鲁克"></a>韦斯特布鲁克</h3><p>场均31.8分，10.7个篮板，10.4次助攻，雷霆战绩西部第六。</p><p>至今已经拿到41个三双，赛季场均三双已成事实，破罗伯特森记录也是指日可待。同时也是NBA史上得分最高的三双。</p><p>但也许会是个悲剧，因为哈登同样出色。就像2005-2006赛季的科比，当年科比以场均35.4分打破了NBA自1970年有纪录以来的最高得分，并且三次入选月最佳球员，轰下单场81分。但由于战绩不佳，最终评委把常规赛MVP给了纳什。</p><p>这个赛季的维斯很像独自带队时的科比，维斯身体素质和得分能力确实厉害，有很强的求胜欲望。能在他身上能找到科比的影子，却始终找不到科比的味道。</p><p><img src="http://okzvb3705.bkt.clouddn.com/image.jpg?imageView2/1/w/1980/h/600/" alt=""></p><h3 id="杜兰特"><a href="#杜兰特" class="headerlink" title="杜兰特"></a>杜兰特</h3><p>场均25.3分，8.2个篮板，4.8次助攻，勇士战绩联盟第一。</p><p>伤病前，还在MVP排行前三，勇士战绩也一直占据联盟第一。个人不是很喜欢杜兰特来勇士，因为压缩了库里的表现。希望这个赛季能夺冠，不然就呵呵了。</p><h3 id="詹姆斯"><a href="#詹姆斯" class="headerlink" title="詹姆斯"></a>詹姆斯</h3><p>场均26.3分，8.5个篮板，8.7次助攻，骑士战绩东部第一。</p><p>数据接近三双，几个赛季前，我就说过詹姆斯已经老了，然后看他这两个赛季的表现来说，并没有。也许不吃猪肉真的能保持好的身体。</p><h3 id="库里"><a href="#库里" class="headerlink" title="库里"></a>库里</h3><p>场均25.3分，4.5个篮板，6.6次助攻，勇士战绩联盟第一。</p><p>相信，库里会是一个最伟大的投手。杜兰特的到来，占用不少球权。相对挤压了部分库里的表现，这个赛季，数据有点缩水。但勇士战绩连续三个赛季联盟第一。</p><h3 id="莱昂纳德"><a href="#莱昂纳德" class="headerlink" title="莱昂纳德"></a>莱昂纳德</h3><p>场均25.7分，5.9个篮板，3.6次助攻，马刺战绩西部第二。</p><p>越是低调的人，越可怕。莱昂纳德一直在成长，有莱昂纳德，马刺还可以再战十年。</p><h3 id="伊赛亚-托马斯"><a href="#伊赛亚-托马斯" class="headerlink" title="伊赛亚.托马斯"></a>伊赛亚.托马斯</h3><p>场均29.1分 2.7个篮板，5.7次助攻，凯尔特人战绩东部第二。</p><p>不愧是地表最强1米75，比1米83的艾弗森更强。很喜欢托马斯，因为他代表我们这类身高的人打篮球，同样可以征服NBA，</p><p>艾弗森也一直是自己的偶像。</p><h3 id="约翰-沃尔"><a href="#约翰-沃尔" class="headerlink" title="约翰.沃尔"></a>约翰.沃尔</h3><p>场均23.2分，4.2个篮板，10.7次助攻，奇才战绩东部第三。</p><p>一直有关注沃尔，就是因为他风驰电掣般的运球速度。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>赛季接近尾声，关于MVP，我认为只剩下三种可能了</p><ol><li>哈登当选，没毛病</li><li>维斯微弱优势当选，评委无法拒绝场均三双不是MVP。</li><li>哈登维斯共同当选</li></ol><p>当然，我对最后是哪种结果都不意外。</p><p>使用到的球员得分数据，来源：<a href="http://nba.stats.qq.com/stats/detail/?order=defen&amp;type=player" target="_blank" rel="noopener">腾讯-NBA数据库</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/maxresdefault.jpg?imageView2/1/w/1980/h/900/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;16-17赛季常规赛接近尾声，西部季后赛球队名单和排名基本确定，反
      
    
    </summary>
    
      <category term="运动爱好者" scheme="https://infullstack.github.io/categories/%E8%BF%90%E5%8A%A8%E7%88%B1%E5%A5%BD%E8%80%85/"/>
    
    
      <category term="nba" scheme="https://infullstack.github.io/tags/nba/"/>
    
      <category term="mvp" scheme="https://infullstack.github.io/tags/mvp/"/>
    
      <category term="科比" scheme="https://infullstack.github.io/tags/%E7%A7%91%E6%AF%94/"/>
    
  </entry>
  
  <entry>
    <title>有效的管理邮件</title>
    <link href="https://infullstack.github.io/email.html"/>
    <id>https://infullstack.github.io/email.html</id>
    <published>2017-04-06T10:01:36.000Z</published>
    <updated>2018-01-04T13:55:02.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/aaron-burden-64849.jpg?imageView2/1/w/1980/h/900/" alt=""></p><p>邮件，作为工作中很重要的东西。工作多年，有自己使用的一些方法和技巧。最近也参加了一个知乎关于邮件处理的live，总结下关于邮件处理的应该注意的一些心得和技巧，合理的利用这些在短期内提高管理电子邮件的效率。</p><h2 id="Zero-Inbox"><a href="#Zero-Inbox" class="headerlink" title="Zero Inbox"></a>Zero Inbox</h2><p>Zero Inbox，意为零收件箱。对每封邮件做到当天处理，保持收件箱清空状态。</p><p>将立即回复和定时回复结合起来，对重要联系人（客户、领导）发来的邮件，或者包含重要事情的邮件，迅速采取相应的行动。其他邮件，可以在一天中选择固定的时间进行统一处理。</p><p>在结束一天工作时，让收件箱空空如也，保证所有的事情都被处理妥当，这不是一个容易养成的习惯。却是可以带来很大的收获，让每天的工作更严谨效率。</p><h2 id="用好过滤器"><a href="#用好过滤器" class="headerlink" title="用好过滤器"></a>用好过滤器</h2><p>设置邮件规则，在收到或发送一封邮件时，能够指挥邮箱对每封邮件进行一系列的条件判断，再根据预设的动作，对邮件进行处理。自定义常用的规则，达到自己满意的效果。</p><p>过滤器常用的条件包含：</p><ul><li>发件人和收件人是谁</li><li>主题或正文包含什么关键字</li></ul><p>过滤器预设的动作包含：</p><ul><li>转移、自动回复、删除</li><li>标记已读</li><li>打标签</li></ul><h2 id="对每封邮件进行4D处理"><a href="#对每封邮件进行4D处理" class="headerlink" title="对每封邮件进行4D处理"></a>对每封邮件进行4D处理</h2><p>4D指，行动(Do)，转发(Delegate)，搁置(Defer)，删除（Delete）</p><ul><li><p><strong>行动</strong> 当发现邮件内容是由你来完成，且能在短时间内完成，则可以立即采取行动。</p></li><li><p><strong>转发</strong> 当发现邮件有更适合的人去完成，或更低成本的完成的时候，可以选择转发。</p></li><li><p><strong>搁置</strong> 当前有重要事情在做，且该邮件内容不能短时间完成，则可以放入到搁置文件夹中。</p></li><li><p><strong>删除</strong> 可以把通知类邮件，放入 已处理 或 通知 文件夹。</p></li></ul><h2 id="写邮件技巧"><a href="#写邮件技巧" class="headerlink" title="写邮件技巧"></a>写邮件技巧</h2><p>掌握并是用这些技巧，真正言简意赅、目的明确的表达邮件内容，写出高质量的邮件，让收件人处理邮件更为轻松。</p><ul><li><p><strong>邮件模版</strong> 配置常用的邮件模版，比如签名档</p></li><li><p><strong>善于利用标题</strong> 增加&lt;信息&gt; &lt;请求&gt; &lt;行动&gt; &lt;周报&gt; &lt;日报&gt; &lt;培训&gt; &lt;重要&gt;等标注，能突出内容主题</p></li><li><p><strong>长邮件提醒</strong> 对于长邮件，在邮件开头做说明，并提取重要信息阐述</p></li><li><p><strong>长邮件结构清晰</strong> 利用标题、颜色、加粗、序号等方式，清晰表达邮件内容</p></li><li><p><strong>给收件人多种选择</strong> 如果需要收件人采取行动时，可以提供多种选择，避免邮件长时间没得到结果</p></li><li><p><strong>重读邮件</strong> 每次发送前，重复读一下邮件内容，语句通顺，主题明确，逻辑清晰</p></li><li><p><strong>总结行动要点</strong> 如果需要收件人采取行动，告知收件人行动要点。</p></li><li><p><strong>一封邮件一个主题</strong> 尽量一封邮件只说一件事情，或者汇总相关的事情。</p></li></ul><h2 id="写好一封邮件"><a href="#写好一封邮件" class="headerlink" title="写好一封邮件"></a>写好一封邮件</h2><p>ABC法则，是一个邮件的框架，帮助你把信息放在正确的位置，把内容分成三个部分，简述Action、背景Backgroud、结尾Close</p><ul><li><p><strong>简述Action</strong> 简明的阐述行动的目的和关键点、点明前因后果，做到准确明白</p></li><li><p><strong>背景Backgroud</strong> 清楚、简洁、相关</p></li><li><p><strong>结尾Close</strong> 阐述下一步行动和小提示、签名</p></li></ul><p>示例：<br><img src="http://okzvb3705.bkt.clouddn.com/91a1d4d90eaf4e6c130868d3e7175027_b.jpg" alt=""></p><p>写邮件跟写博客文章一样，需要经常总结和应用合适的方法和技巧，不日之后，即可顺手拈来。</p><p>本文内容多为网上关于邮件管理的经验之谈，这里做一个适合自己的邮件管理的汇总笔记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/aaron-burden-64849.jpg?imageView2/1/w/1980/h/900/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;邮件，作为工作中很重要的东西。工作多年，有自己使用的一些
      
    
    </summary>
    
      <category term="观点感悟" scheme="https://infullstack.github.io/categories/%E8%A7%82%E7%82%B9%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="邮件" scheme="https://infullstack.github.io/tags/%E9%82%AE%E4%BB%B6/"/>
    
      <category term="管理" scheme="https://infullstack.github.io/tags/%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>读阿里开发手册</title>
    <link href="https://infullstack.github.io/alidevnotes.html"/>
    <id>https://infullstack.github.io/alidevnotes.html</id>
    <published>2017-03-10T09:26:15.000Z</published>
    <updated>2018-01-04T13:52:49.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/galymzhan-abdugalimov-181.jpg?imageView2/1/w/1980/h/900/" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阿里作为全世界Java开发规模最大和应用水平最高的地方之一，三十几页的规范，从编程、异常日志、SQL、工程、安全五块形成的规约总结，根据约束力，分强制、推荐、参考三大类，可以作为优秀技术团队的重要利器。</p><p><strong>官方文档地址：<a href="https://yq.aliyun.com/articles/69327?utm_content=m_10088" target="_blank" rel="noopener">https://yq.aliyun.com/articles/69327?utm_content=m_10088</a></strong></p><p>以下是阅读阿里开发手册中，记录的一些重要摘要信息。</p><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ol><li>尽量语义清晰、望名知义</li><li>遵从驼峰形式</li><li>如果使用到了设计模式，类名体现具体模式</li></ol><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><ol><li>值定义不要出现未定义的常量</li><li>常量类推荐也分类定义常量类，不要大而全的一个常量类</li><li>变量值在一定范围，使用Enum类</li></ol><h3 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h3><ol><li>单行限制不超过120个字符</li></ol><p>看注释内容，示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 缩进4个空格</span><br><span class="line">String say = &quot;hello&quot;;</span><br><span class="line">// 运算符的左右必须有一个空格</span><br><span class="line">int flag = 0;</span><br><span class="line">// 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格</span><br><span class="line">if (flag == 0) &#123;</span><br><span class="line">System.out.println(say);</span><br><span class="line">&#125;</span><br><span class="line">// 左大括号前加空格且不换行；左大括号后换行</span><br><span class="line">if (flag == 1) &#123;</span><br><span class="line">System.out.println(&quot;world&quot;);</span><br><span class="line">// 右大括号前换行，右大括号后有else，不用换行</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;ok&quot;);</span><br><span class="line">// 在右大括号后直接结束，则必须换行</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OOP规约"><a href="#OOP规约" class="headerlink" title="OOP规约"></a>OOP规约</h3><ol><li>overwrite方法，必须有@overwrite注解</li><li>静态方法和变量，直接通过类名访问，禁止对象访问，增加无谓的编译器解释成本</li><li>不能使用过时的类或方法</li><li>包装类之间的值比较，使用equals方法</li><li><strong>构造方法禁止加入任何业务逻辑，请放在init方法中</strong></li><li>String的split方法，做分隔符后无内容的检测</li><li>类方法定义的顺序，公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法</li><li>getter/setter方法尽量不要加入任何业务逻辑，增加排查问题的难度</li><li>推荐使用StringBuilder的append方法替换string拼接</li></ol><h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><ol><li>线程定义名称</li><li>使用线程池，使用ThreadPoolExecutor</li><li>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</li><li>使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至await方法，直到超时才返回结果。</li></ol><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><p>1.推荐尽量少用else， if-else的方式可以改写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">// 接着写else的业务逻辑代码;</span><br></pre></td></tr></table></figure></p><ol><li>a</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>类、属性、方法，使用/<em>*内容</em>/定义注释，不得使用//注释</li><li>抽象方法、枚举，详细注释</li><li>注释掉的代码，配合说明</li></ol><h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>RuntimeException预先检查进行规避，避免IndexOutofBoundsException/NullPointerException</li><li>异常不能用来做流程控制、条件控制，比条件判断效率低</li><li>finally需要关闭资源、流、连接等</li><li>避免出现重复代码</li></ol><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ol><li>使用SLF4J日志框架的API，不直接使用log4j/logback</li><li>日志文件命名，含义清晰</li><li><p>异常信息，包含现场信息和堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.error(各类参数或者对象toString + &quot;_&quot; + e.getMessage(), e);</span><br></pre></td></tr></table></figure></li><li><p>使用条件输出或占位输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正例：（条件）</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);</span><br><span class="line">&#125;</span><br><span class="line">正例：（占位符）</span><br><span class="line">logger.debug(&quot;Processing trade with id: &#123;&#125; symbol : &#123;&#125; &quot;, id, symbol);</span><br></pre></td></tr></table></figure></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL规约中，MySQL使用方法都是比较有用的经验之选，推荐都仔细研读。</p><p>###　建表</p><ol><li>使用小写字母，数字，下划线命名</li><li>尽量不修改表名、字段名</li><li>主键pk<em> ,索引 idx</em> ,唯一 uk_</li><li>小数类型为decimal，禁止使用float和double。</li><li>如果存储的字符串长度几乎相等，使用char定长字符串类型</li></ol><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ol><li>join字段类型一致、禁止超过3表join</li><li>在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</li><li>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。右模糊可以利用b+树最左前缀匹配</li><li>利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</li></ol><h3 id="SQL规约"><a href="#SQL规约" class="headerlink" title="SQL规约"></a>SQL规约</h3><ol><li>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</li><li>【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</li><li>【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。</li></ol><h3 id="ORM规约"><a href="#ORM规约" class="headerlink" title="ORM规约"></a>ORM规约</h3><ol><li>在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</li><li>@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li></ol><h2 id="工程规约"><a href="#工程规约" class="headerlink" title="工程规约"></a>工程规约</h2><h3 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h3><p><a href="http://infullstack.com/?attachment_id=242" rel="noopener" target="_blank"><img src="http://infullstack.com/wp-content/uploads/2017/03/微信图片_20170310171602.png" alt="" width="400" height="345" class="aligncenter size-full wp-image-242"></a></p><p>图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推：</p><ul><li>开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。</li><li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。</li><li>Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li>Service层：相对具体的业务逻辑服务层。</li><li>Manager层：通用业务处理层，它有如下特征： 1） 对第三方平台封装的层，预处理返回结果及转化异常信息； 2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理； 3） 与DAO层交互，对多个DAO的组合复用。</li><li>DAO层：数据访问层，与底层MySQL、Oracle、Hbase进行数据交互。</li><li>外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</li></ul><h3 id="服务器规约"><a href="#服务器规约" class="headerlink" title="服务器规约"></a>服务器规约</h3><ol><li>给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。</li><li>高并发服务器建议调小TCP协议的time_wait超时时间。</li></ol><h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><p>用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致：</p><ul><li>page size过大导致内存溢出</li><li>恶意order by导致数据库慢查询</li><li>任意重定向</li><li>SQL注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务ReDoS</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="分层领域模型规约"><a href="#分层领域模型规约" class="headerlink" title="分层领域模型规约"></a>分层领域模型规约</h3><ul><li><strong>DO（Data Object）</strong>：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li><strong>DTO（Data Transfer Object）</strong>：数据传输对象，Service和Manager向外传输的对象。</li><li><strong>BO（Business Object）</strong>：业务对象。可以由Service层输出的封装业务逻辑的对象。</li><li><strong>QUERY</strong>：数据查询对象，各层接收上层的查询请求。注：超过2个参数的查询封装，禁止使用Map类来传输。</li><li><strong>VO（View Object）</strong>：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li></ul><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3><ol><li><strong>POJO</strong>（Plain Ordinary Java Object）：在本规约中，POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。 </li><li><strong>DO</strong>（Data Object）：本手册指数据库表一一对应的POJO类。 </li><li><strong>GAV</strong>（GroupId、ArtifactctId、Version）：Maven坐标，是用来唯一标识jar包。 </li><li><strong>OOP</strong>（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。 </li><li><strong>ORM</strong>（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指iBATIS, mybatis等框架。 </li><li><strong>NPE</strong>（java.lang.NullPointerException）: 空指针异常。 </li><li><strong>一方库</strong>：本工程内部子项目模块依赖的库（jar包）。 </li><li><strong>二方库</strong>：公司内部发布到中央仓库，可供公司内部依赖的库（jar包）。 </li><li><strong>三方库</strong>：公司之外的开源的依赖库（jar包）</li></ol><p><strong>官方文档地址：<a href="https://yq.aliyun.com/articles/69327?utm_content=m_10088" target="_blank" rel="noopener">https://yq.aliyun.com/articles/69327?utm_content=m_10088</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/galymzhan-abdugalimov-181.jpg?imageView2/1/w/1980/h/900/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://infullstack.github.io/tags/java/"/>
    
      <category term="阿里" scheme="https://infullstack.github.io/tags/%E9%98%BF%E9%87%8C/"/>
    
      <category term="规范" scheme="https://infullstack.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>shell通用日志函数</title>
    <link href="https://infullstack.github.io/shell-log-function.html"/>
    <id>https://infullstack.github.io/shell-log-function.html</id>
    <published>2017-01-11T03:46:14.000Z</published>
    <updated>2018-01-04T13:59:14.479Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便调试，写了一个通用的日志函数，实现功能：</p><ol><li>设定日志级别，实现可以输出不同级别的日志信息 </li><li>日志格式类似为：[日志级别] 时间 funcname:函数名 [lineno:行号] 日志信息 </li><li>不同级别，设定不同颜色 </li></ol><p><strong>代码:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function log &#123;</span><br><span class="line">    local text;local logtype</span><br><span class="line">    logfile=/var/log/mylog/mylog.log</span><br><span class="line">    logtype=$1</span><br><span class="line">    text=$2</span><br><span class="line">message=&quot;`date +&apos;%F %H:%M:%S&apos;` $1 line:$LINENO $2&quot;</span><br><span class="line">    case $logtype in </span><br><span class="line">        error)</span><br><span class="line">            echo -e &quot;\033[31m$&#123;message&#125;\033[0m&quot; | tee -a $logfile;;</span><br><span class="line">        info)</span><br><span class="line">            echo -e &quot;\033[32m$&#123;message&#125;\033[0m&quot; | tee -a $logfile;;</span><br><span class="line">        warn)</span><br><span class="line">            echo -e &quot;\033[33m$&#123;message&#125;\033[0m&quot; | tee -a $logfile;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log info &quot;this&apos;s info log&quot;</span><br><span class="line">log error &quot;this&apos;s error log&quot;</span><br><span class="line">log warn &quot;this&apos;s warn log&quot;</span><br></pre></td></tr></table></figure><p><strong>注:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local : 局部变量</span><br><span class="line">$LINENO：shell 脚本行数</span><br><span class="line">$1 $2 ：函数参数</span><br><span class="line">tee 输出到控制台和文件</span><br><span class="line">\033[31m \033[0m : echo 输出颜色</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了方便调试，写了一个通用的日志函数，实现功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设定日志级别，实现可以输出不同级别的日志信息 &lt;/li&gt;
&lt;li&gt;日志格式类似为：[日志级别] 时间 funcname:函数名 [lineno:行号] 日志信息 &lt;/li&gt;
&lt;li&gt;不同级别，设定不
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="https://infullstack.github.io/tags/shell/"/>
    
      <category term="日志" scheme="https://infullstack.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="log" scheme="https://infullstack.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="https://infullstack.github.io/nginx-load-balancing.html"/>
    <id>https://infullstack.github.io/nginx-load-balancing.html</id>
    <published>2017-01-03T03:50:25.000Z</published>
    <updated>2018-01-04T13:58:42.768Z</updated>
    
    <content type="html"><![CDATA[<p>nginx可以按照调度规则实现动态、静态页面的分离，也可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡，同时还支持后端服务器的健康检查。</p><p>nginx的upstream目前支持的5种方式的分配</p><p><strong>1.轮询（默认）</strong></p><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">    server 192.168.0.14; </span><br><span class="line">    server 192.168.0.15; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.指定权重</strong></p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">    server 192.168.0.14 weight=10; </span><br><span class="line">    server 192.168.0.15 weight=10; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.IP绑定 ip_hash (session绑定)</strong></p><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 192.168.0.14:88; </span><br><span class="line">    server 192.168.0.15:80; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.fair（第三方）</strong></p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">    server server1; </span><br><span class="line">    server server2; </span><br><span class="line">    fair; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.url_hash（第三方）</strong></p><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">    server squid1:3128; </span><br><span class="line">    server squid2:3128; </span><br><span class="line">    hash $request_uri; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用负载均衡的server中增加<br>示例配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxy_pass http://backserver/; </span><br><span class="line">upstream backserver&#123; </span><br><span class="line">    ip_hash; </span><br><span class="line">    server 127.0.0.1:9090 down; (down 表示单前的server暂时不参与负载) </span><br><span class="line">    server 127.0.0.1:8080 weight=2; (weight 默认为1.weight越大，负载的权重就越大) </span><br><span class="line">    server 127.0.0.1:6060; </span><br><span class="line">    server 127.0.0.1:7070 backup; (其它所有的非backup机器down或者忙的时候，请求backup机器) </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">max_fails ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误</span><br><span class="line">fail_timeout:max_fails次失败后，暂停的时间</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx可以按照调度规则实现动态、静态页面的分离，也可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡，同时还支持后端服务器的健康检查。&lt;/p&gt;
&lt;p&gt;nginx的upstream目前支持的5种方式的分配&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.轮询（默认
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="https://infullstack.github.io/tags/nginx/"/>
    
      <category term="负载均衡" scheme="https://infullstack.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JFinal增加简单权限认证功能</title>
    <link href="https://infullstack.github.io/jfinal-auth.html"/>
    <id>https://infullstack.github.io/jfinal-auth.html</id>
    <published>2017-01-03T03:03:53.000Z</published>
    <updated>2018-01-04T13:57:32.269Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://okzvb3705.bkt.clouddn.com/maja-petric-8287.jpg?imageView2/1/w/1980/h/900/" alt=""></p><h2 id="JFinal"><a href="#JFinal" class="headerlink" title="JFinal"></a>JFinal</h2><p>JFinal 是基于 Java 语言的极速 WEB + ORM 框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展、Restful。在拥有Java语言所有优势的同时再拥有ruby、python、php等动态语言的开发效率！</p><p>基于JFinal有shiro权限认证模块。这里使用interceptor和session实现简单的权限认证功能。</p><h2 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h2><p>每个action请求，都会校验session中是否登录成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CommonInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">public static List&lt;String&gt; noLoginAction;</span><br><span class="line"></span><br><span class="line">public CommonInterceptor() &#123;</span><br><span class="line">noLoginAction = new ArrayList&lt;String&gt;();</span><br><span class="line">noLoginAction.add(&quot;/login&quot;);</span><br><span class="line">noLoginAction.add(&quot;/doLogin&quot;);</span><br><span class="line">noLoginAction.add(&quot;/logout&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void intercept(Invocation inv) &#123;</span><br><span class="line">Controller controller = inv.getController();</span><br><span class="line">try &#123;</span><br><span class="line">HttpSession session = controller.getSession();</span><br><span class="line">boolean flag = (boolean) (session.getAttribute(&quot;islogin&quot;) != null ? session.getAttribute(&quot;islogin&quot;): false);</span><br><span class="line">if (flag) &#123;</span><br><span class="line">// 登录后调整到首页，不进入login页面</span><br><span class="line">if (IndexController.LOGIN_URL.equals(inv.getActionKey())) &#123;</span><br><span class="line">controller.redirect(IndexController.LOGIN_SUCCESS_URL);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">inv.invoke();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (noLoginAction.contains(inv.getActionKey())) &#123;</span><br><span class="line">inv.invoke();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">controller.redirect(IndexController.LOGIN_URL);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">controller.redirect(&quot;/&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>登录时判断用户和密码是否匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void login() &#123;</span><br><span class="line">this.render(&quot;/auth/login.html&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void doLogin() &#123;</span><br><span class="line">String username = this.getPara(&quot;username&quot;);</span><br><span class="line">String password = this.getPara(&quot;password&quot;);</span><br><span class="line">if (&quot;admin&quot;.equals(username) &amp;&amp; password.equals(&quot;admin&quot;)) &#123;</span><br><span class="line">setSessionAttr(&quot;islogin&quot;, true);</span><br><span class="line">&#125;</span><br><span class="line">this.redirect(&quot;/&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void logout() &#123;</span><br><span class="line">setSessionAttr(&quot;islogin&quot;, false);</span><br><span class="line">this.redirect(LOGIN_URL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>在Config中增加Interceptor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 配置全局拦截器</span><br><span class="line">*/</span><br><span class="line">public void configInterceptor(Interceptors me) &#123;</span><br><span class="line">me.add(new CommonInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://okzvb3705.bkt.clouddn.com/maja-petric-8287.jpg?imageView2/1/w/1980/h/900/&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JFinal&quot;&gt;&lt;a href=&quot;#JFinal&quot;
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jfinal" scheme="https://infullstack.github.io/tags/jfinal/"/>
    
      <category term="认证" scheme="https://infullstack.github.io/tags/%E8%AE%A4%E8%AF%81/"/>
    
      <category term="权限" scheme="https://infullstack.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+Tomcat实现应用负载均衡</title>
    <link href="https://infullstack.github.io/nginx-tomcat-load-balancing.html"/>
    <id>https://infullstack.github.io/nginx-tomcat-load-balancing.html</id>
    <published>2016-12-30T09:01:57.000Z</published>
    <updated>2018-01-04T13:58:55.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当单个应用服务器压力过大时，可以使用多个应用服务器提供服务减轻单服务器的压力，再结合一个代理转发服务器，完成tomcat的负载均衡。</p><p>部署架构图<br><img src="http://infullstack.com/wp-content/uploads/2016/12/nginx_tomcat.png" alt="" width="500" class="aligncenter size-full wp-image-100"></p><p>特点：<br>当请求达到nginx，nginx会根据weight和配置的服务器列表，完成请求的转发，实现应用服务器的负载均衡。<br>该架构适用于无状态共享的应用服务，因为session并没有设置共享。</p><h3 id="用到工具"><a href="#用到工具" class="headerlink" title="用到工具"></a>用到工具</h3><ul><li>nginx 1.10</li><li>tomcat 1.8</li></ul><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><em>三个节点</em></p><ul><li>172.16.2.41 Tomcat  tomcat_41</li><li>172.16.2.42 Tomcat  tomcat_42</li><li>172.16.2.43 Nginx   nginx_43</li></ul><h2 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h2><h3 id="配置端口-conf-server-xml"><a href="#配置端口-conf-server-xml" class="headerlink" title="配置端口(conf/server.xml)"></a>配置端口(conf/server.xml)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;1010&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="新增首页"><a href="#新增首页" class="headerlink" title="新增首页"></a>新增首页</h3><p>新增应用服务器首页，tomcat/webapps/ROOT/index.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata01 ROOT]<span class="comment"># echo 'tomcat at 41 !' &gt; index.html</span></span><br><span class="line">[root@bigdata01 ROOT]<span class="comment"># cat index.html </span></span><br><span class="line">tomcat at 41 !</span><br><span class="line">[root@bigdata01 ROOT]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@transwarp1 bin]<span class="comment"># ./startup.sh </span></span><br><span class="line">Using CATALINA_BASE:   /mnt/disk1/ray/tomcat</span><br><span class="line">Using CATALINA_HOME:   /mnt/disk1/ray/tomcat</span><br><span class="line">Using CATALINA_TMPDIR: /mnt/disk1/ray/tomcat/temp</span><br><span class="line">Using JRE_HOME:        /usr/java/latest</span><br><span class="line">Using CLASSPATH:       /mnt/disk1/ray/tomcat/bin/bootstrap.jar:/mnt/disk1/ray/tomcat/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br><span class="line">[root@transwarp1 bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="配置tomcat2"><a href="#配置tomcat2" class="headerlink" title="配置tomcat2"></a>配置tomcat2</h3><p>方法同上。</p><h2 id="部署Nginx"><a href="#部署Nginx" class="headerlink" title="部署Nginx"></a>部署Nginx</h2><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><p>参考文章：<a href="http://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">Nginx 安装配置</a></p><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream infullstack.com&#123;  #集群名称</span><br><span class="line">    server172.16.2.41:1010weight=1;# 服务器列表，请求会转发到这些服务器</span><br><span class="line">    server172.16.2.42:1010weight=2;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       88;  # nginx端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_passhttp://infullstack.com; #集群名称</span><br><span class="line">            proxy_redirectdefault;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动和访问Nginx"><a href="#启动和访问Nginx" class="headerlink" title="启动和访问Nginx"></a>启动和访问Nginx</h2><p>访问<a href="http://172.16.2.43:88/" target="_blank" rel="noopener">http://172.16.2.43:88/</a></p><p>刷新页面，会发现请求会转发到41和42服务器</p><p><img src="http://infullstack.com/wp-content/uploads/2016/12/41.png" alt="" width="505" height="142" class="alignnone size-full wp-image-101"><br><img src="http://infullstack.com/wp-content/uploads/2016/12/42.png" alt="" width="586" height="189" class="alignnone size-full wp-image-102"></p><p>根据应用服务器的配置和需求，可以修改weight，配置服务器的权重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当单个应用服务器压力过大时，可以使用多个应用服务器提供服务减轻单服务器的压力，再结合一个代理转发服务器，完成tomcat的负载均衡。&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="https://infullstack.github.io/tags/nginx/"/>
    
      <category term="tomcat" scheme="https://infullstack.github.io/tags/tomcat/"/>
    
      <category term="负载均衡" scheme="https://infullstack.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>实现shell并发</title>
    <link href="https://infullstack.github.io/shell-concruent.html"/>
    <id>https://infullstack.github.io/shell-concruent.html</id>
    <published>2016-12-09T09:42:45.000Z</published>
    <updated>2018-01-04T13:54:08.330Z</updated>
    
    <content type="html"><![CDATA[<p>经常在工作中遇到执行的脚本需要并发执行，提高效率。</p><ul><li>常规脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!bin/sh</span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">&#123;</span><br><span class="line">    sleep 3;</span><br><span class="line">    echo $i</span><br><span class="line">&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行：time bash test.sh<br>执行结果：总共耗时15秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@pc disk1]# time sh test.sh</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">real0m15.010s</span><br><span class="line">user0m0.003s</span><br><span class="line">sys0m0.005s</span><br><span class="line">[root@pc disk1]#</span><br></pre></td></tr></table></figure><ul><li>并发脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!bin/sh</span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">&#123;</span><br><span class="line">    sleep 3;</span><br><span class="line">    echo $i</span><br><span class="line">&#125;&amp;</span><br><span class="line">done</span><br><span class="line">wait</span><br><span class="line">echo &apos;over&apos;</span><br></pre></td></tr></table></figure><p>每次for循环后加了一个后台执行&amp;符号，那5个循环任务会并发执行,执行：time bash concurrent.sh<br>执行结果：总耗时3秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@pc disk1]# time sh concurrent.sh </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">over</span><br><span class="line"></span><br><span class="line">real0m3.004s</span><br><span class="line">user0m0.001s</span><br><span class="line">sys0m0.002s</span><br><span class="line">[root@pc disk1]#</span><br></pre></td></tr></table></figure><blockquote><p>wait的作用：等待前面后台执行的任务全部结束再往下执行，否则程序会直接执行结束。当然后台执行的脚本还会继续执行，只不过会影响wait后续的代码。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常在工作中遇到执行的脚本需要并发执行，提高效率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="https://infullstack.github.io/tags/shell/"/>
    
      <category term="并发" scheme="https://infullstack.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置supervisor管理进程</title>
    <link href="https://infullstack.github.io/linux-supervisor.html"/>
    <id>https://infullstack.github.io/linux-supervisor.html</id>
    <published>2016-12-09T03:15:19.000Z</published>
    <updated>2018-01-04T13:58:00.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Supervisor是由python语言编写，基于linux操作系统的一款服务器管理工具，<br>用以监控服务器的运行，发现问题能立即自动预警及自动重启等功能。</p><h3 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h3><ul><li>Centos 6.5</li><li>Python 2.6.6</li></ul><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><ul><li>supervisor</li><li>meld(python html模版引擎)</li></ul><p>下载地址：</p><p>meld3 <a href="http://www.plope.com/software/meld3/meld3-0.6.5.tar.gz" target="_blank" rel="noopener">http://www.plope.com/software/meld3/meld3-0.6.5.tar.gz</a></p><p>supervisor</p><p><a href="http://pypi.python.org/packages/source/s/supervisor/supervisor-3.0b1.tar.gz" target="_blank" rel="noopener">http://pypi.python.org/packages/source/s/supervisor/supervisor-3.0b1.tar.gz</a></p><p>下载解压，分别执行python setup.py install安装</p><h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><ol><li>创建配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><ol><li>修改配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 增加web监控服务</span><br><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=0.0.0.0:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">username=user              ; (default is no username (open server))</span><br><span class="line">password=123               ; (default is no password (open server))</span><br><span class="line"></span><br><span class="line"># 增加监控程序</span><br><span class="line">[program:tail1]                                                                            </span><br><span class="line">command=tail -f  /etc/supervisord.conf   ;常驻后台的命令</span><br><span class="line">autostart=true                           ;是否随supervisor启动</span><br><span class="line">autorestart=true                         ;是否在挂了之后重启，意外关闭后会重启，比如kill掉！</span><br><span class="line">startretries=3                           ;启动尝试次数</span><br><span class="line">stderr_logfile=/tmp/tail1.err.log        ;标准输出的位置</span><br><span class="line">stdout_logfile=/tmp/tail1.out.log        ;标准错误输出的位置</span><br><span class="line"></span><br><span class="line"># 也可以监控目录下配置文件，监控/etc/supervisord.d/目录下conf后缀文件，conf中配置监控程序</span><br><span class="line">[include]</span><br><span class="line">files=/etc/supervisord.d/*.conf</span><br></pre></td></tr></table></figure><h3 id="启动监控"><a href="#启动监控" class="headerlink" title="启动监控"></a>启动监控</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>访问浏览器ip:9001</p><p><img src="http://infullstack.com/wp-content/uploads/2016/12/supervisor.png" alt=""></p><h3 id="supervisorctl管理程序进程"><a href="#supervisorctl管理程序进程" class="headerlink" title="supervisorctl管理程序进程"></a>supervisorctl管理程序进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 查询状态</span><br><span class="line">upervisorctl status        </span><br><span class="line"># 开启服务</span><br><span class="line">supervisorctl start hello    </span><br><span class="line"># 关闭服务</span><br><span class="line">supervisorctl stop hello</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line"></span><br><span class="line"># 停止某一个进程(programxxx)，programxxx为[program:chatdemon]里配置的值，这个示例就是programname</span><br><span class="line">supervisorctl stop programname</span><br><span class="line"># 启动某个进程</span><br><span class="line">supervisorctl start programname</span><br><span class="line"># 重启某个进程</span><br><span class="line">supervisorctl restart programname</span><br><span class="line"># 重启所有属于名为groupworker这个分组的进程(start,restart同理)</span><br><span class="line">supervisorctl stop groupworker</span><br><span class="line"># 停止全部进程，注：start、restart、stop都不会载入最新的配置文件</span><br><span class="line">supervisorctl stop all</span><br><span class="line"># 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程</span><br><span class="line">supervisorctl reload</span><br><span class="line">根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</span><br><span class="line">supervisorctl update，</span><br></pre></td></tr></table></figure><h3 id="增加程序启动停止脚本"><a href="#增加程序启动停止脚本" class="headerlink" title="增加程序启动停止脚本"></a>增加程序启动停止脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># /etc/init.d/supervisord</span><br><span class="line">#</span><br><span class="line"># Supervisor is a client/server system that</span><br><span class="line"># allows its users to monitor and control a</span><br><span class="line"># number of processes on UNIX-like operating</span><br><span class="line"># systems.</span><br><span class="line">#</span><br><span class="line"># chkconfig: - 64 36</span><br><span class="line"># description: Supervisor Server</span><br><span class="line"># processname: supervisord</span><br><span class="line"> </span><br><span class="line"># Source init functions</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"> </span><br><span class="line">prog=&quot;supervisord&quot;</span><br><span class="line"> </span><br><span class="line">prefix=&quot;/usr&quot;</span><br><span class="line">exec_prefix=&quot;$&#123;prefix&#125;&quot;</span><br><span class="line">prog_bin=&quot;$&#123;exec_prefix&#125;/bin/supervisord&quot;</span><br><span class="line">PIDFILE=&quot;/var/run/$prog.pid&quot;</span><br><span class="line"> </span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">       echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">       ###注意下面这一行一定得有-c /etc/supervisord.conf   不然修改了配置文件根本不生效！</span><br><span class="line">       daemon $prog_bin -c /etc/supervisord.conf --pidfile $PIDFILE</span><br><span class="line">       [ -f $PIDFILE ] &amp;&amp; success $&quot;$prog startup&quot; || failure $&quot;$prog startup&quot;</span><br><span class="line">       echo</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">       echo -n $&quot;Shutting down $prog: &quot;</span><br><span class="line">       [ -f $PIDFILE ] &amp;&amp; killproc $prog || success $&quot;$prog shutdown&quot;</span><br><span class="line">       echo</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line"> </span><br><span class="line"> start)</span><br><span class="line">   start</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line"> stop)</span><br><span class="line">   stop</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line"> status)</span><br><span class="line">       status $prog</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line"> restart)</span><br><span class="line">   stop</span><br><span class="line">   start</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line"> *)</span><br><span class="line">   echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;</span><br><span class="line"> ;;</span><br><span class="line"> </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>然后加入启动项呗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/supervisord</span><br><span class="line">chkconfig --add supervisord</span><br><span class="line">chkconfig supervisord on</span><br><span class="line">service supervisord start</span><br></pre></td></tr></table></figure><p>这样可以通过/etc/init.d/supervisord start | stop |restart 来管理supervisord</p><p>参考内容：<a href="http://supervisord.org/" target="_blank" rel="noopener">http://supervisord.org/</a></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Flume为数据采集工具，但缺乏监控工具，Flume进程的状态不能实时看到，且进程停止不回自动重启，可以利用Supervisor来完成这些工作。</p><h3 id="安装配置Supervisor"><a href="#安装配置Supervisor" class="headerlink" title="安装配置Supervisor"></a>安装配置Supervisor</h3><p>参考文章 <a href="http://infullstack.com/linux_supervisor.html" target="_blank" rel="noopener">http://infullstack.com/linux_supervisor.html</a></p><h3 id="配置-etc-supervisord-conf"><a href="#配置-etc-supervisord-conf" class="headerlink" title="配置/etc/supervisord.conf"></a>配置/etc/supervisord.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:flume] </span><br><span class="line">command=sh /usr/lib/flume/bin/flume-ng agent --conf /usr/lib/flume/conf/ -f /usr/lib/flume/conf/flume.conf -n agent1 -Dflume.root.logger=INFO,console</span><br><span class="line">autostart=true                           ;是否随supervisor启动</span><br><span class="line">autorestart=true                         ;是否在挂了之后重启，意外关闭后会重启，比如kill掉！</span><br><span class="line">startretries=3                           ;启动尝试次数</span><br><span class="line">stderr_logfile=/tmp/flume.err.log        ;标准输出的位置</span><br><span class="line">stdout_logfile=/tmp/flume.out.log        ;标准错误输出的位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 也可以监控目录下配置文件，监控/etc/supervisord.d/目录下conf后缀文件，conf文件中配置监控上述内容</span><br><span class="line">[include]</span><br><span class="line">files=/etc/supervisord.d/*.conf</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>程序不需要提前启动，supervisor启动的时候会启动Flume</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Supervisor是由python语言编写，基于linux操作系统的一款服务器管理工具，&lt;br&gt;用以监控服务器的运行，发现问题能立即自动预
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://infullstack.github.io/tags/linux/"/>
    
      <category term="supervisor" scheme="https://infullstack.github.io/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>收集jmap和jstack信息</title>
    <link href="https://infullstack.github.io/collect-jmap-jstack.html"/>
    <id>https://infullstack.github.io/collect-jmap-jstack.html</id>
    <published>2016-12-05T11:15:41.000Z</published>
    <updated>2018-01-04T13:54:56.120Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#收集jmap信息</span><br><span class="line"></span><br><span class="line">#!bin/sh</span><br><span class="line">if [ $# -lt 2 ] ; then</span><br><span class="line">echo &quot;please input port and execute count parameter&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">jmap_dir=/mnt/ray/jmap/</span><br><span class="line">jstack_dir=/mnt/ray/jstack/</span><br><span class="line">port=$1</span><br><span class="line">count=$2</span><br><span class="line">i=1</span><br><span class="line">while(($i&lt;$count))</span><br><span class="line">do</span><br><span class="line">filename=`date &apos;+%Y-%m-%d_%H:%M:%S&apos;`</span><br><span class="line">sudo -u hive /usr/java/latest/bin/jmap -histo $port  &gt; $jmap_dir$filename&quot;_&quot;$port.jmap</span><br><span class="line">        sudo -u hive /usr/java/latest/bin/jmap -heap $port  &gt;&gt; $jmap_dir$filename&quot;_&quot;$port.jmap</span><br><span class="line">sudo -u hive /usr/java/latest/bin/jstack $port &gt; $jstack_dir$filename&quot;_&quot;$port.jstack</span><br><span class="line">i=$(($i+1))</span><br><span class="line">sleep 1m</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#收集jstack信息</span><br><span class="line">#!bin/sh</span><br><span class="line">jmap_dir=/mnt/ray/jmap/</span><br><span class="line">jstack_dir=/mnt/ray/jstack/</span><br><span class="line">count=$1</span><br><span class="line">i=1</span><br><span class="line">mkdir /mnt/ray/jmap/</span><br><span class="line">mkdir /mnt/ray/jstack/</span><br><span class="line">while(($i&lt;$count))</span><br><span class="line">do</span><br><span class="line">for port in $(jps|grep CoarseGrainedExecutorBackend|awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">do</span><br><span class="line">filename=`date &apos;+%Y-%m-%d_%H:%M:%S&apos;`</span><br><span class="line">sudo -u hive /usr/java/latest/bin/jmap -histo $port &gt; $jmap_dir$filename&quot;_&quot;$port.jmap</span><br><span class="line">   sudo -u hive /usr/java/latest/bin/jmap -heap $port &gt;&gt; $jmap_dir$filename&quot;_&quot;$port.jmap</span><br><span class="line">sudo -u hive /usr/java/latest/bin/jstack $port &gt; $jstack_dir$filename&quot;_&quot;$port.jstack</span><br><span class="line">i=$(($i+1))</span><br><span class="line">sleep 1m</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh jmap.sh 16019 &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://infullstack.github.io/tags/java/"/>
    
      <category term="jmap" scheme="https://infullstack.github.io/tags/jmap/"/>
    
      <category term="jstack" scheme="https://infullstack.github.io/tags/jstack/"/>
    
  </entry>
  
  <entry>
    <title>书单</title>
    <link href="https://infullstack.github.io/booklist.html"/>
    <id>https://infullstack.github.io/booklist.html</id>
    <published>2016-09-08T04:01:47.000Z</published>
    <updated>2018-01-04T13:53:10.688Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="书" scheme="https://infullstack.github.io/tags/%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>常用的linux命令</title>
    <link href="https://infullstack.github.io/linux-command.html"/>
    <id>https://infullstack.github.io/linux-command.html</id>
    <published>2016-01-03T04:48:20.000Z</published>
    <updated>2018-01-04T13:54:45.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Linux-kill多个进程"><a href="#Linux-kill多个进程" class="headerlink" title="Linux kill多个进程"></a>Linux kill多个进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep ycsb|grep -v grep|cut -c 9-15|xargs kill -9</span><br></pre></td></tr></table></figure><h4 id="列举根目录文件下文件大小"><a href="#列举根目录文件下文件大小" class="headerlink" title="列举根目录文件下文件大小"></a>列举根目录文件下文件大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du / -m --max-depth 1 |sort -nr</span><br></pre></td></tr></table></figure><p>####　查看端口占用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat　-anp|grep port</span><br><span class="line">即：netstat –apn | grep 8080</span><br></pre></td></tr></table></figure><h4 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r magic /usr/src　　#显示/usr/src目录下的文件(包含子目录)包含magic的行</span><br></pre></td></tr></table></figure><h4 id="使用混合查找方式查找文件"><a href="#使用混合查找方式查找文件" class="headerlink" title="使用混合查找方式查找文件"></a>使用混合查找方式查找文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /tmp -size +10000c -and -mtime +2 　　#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</span><br></pre></td></tr></table></figure><h4 id="Linux光盘挂载"><a href="#Linux光盘挂载" class="headerlink" title="Linux光盘挂载"></a>Linux光盘挂载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t iso9660 -o loop CentOs.iso /mnt/cdrom</span><br></pre></td></tr></table></figure><h4 id="根据-CPU-使用来升序排序"><a href="#根据-CPU-使用来升序排序" class="headerlink" title="根据 CPU 使用来升序排序"></a>根据 CPU 使用来升序排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --sort -pcpu | less</span><br></pre></td></tr></table></figure><p>for host in VM-233-25-centos VM-226-228-centos VM-252-84-centos VM-232-137-centos VM-251-49-centos VM-249-233-centos VM-101-129-centos VM-101-234-centos; do ssh $host yum clean all; done</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Linux-kill多个进程&quot;&gt;&lt;a href=&quot;#Linux-kill多个进程&quot; class=&quot;headerlink&quot; title=&quot;Linux kill多个进程&quot;&gt;&lt;/a&gt;Linux kill多个进程&lt;/h4&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="编程技术" scheme="https://infullstack.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://infullstack.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一首英文歌</title>
    <link href="https://infullstack.github.io/a-english-song.html"/>
    <id>https://infullstack.github.io/a-english-song.html</id>
    <published>2015-11-02T08:30:11.000Z</published>
    <updated>2018-01-04T13:53:03.277Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hiding from the rain and snow </span><br><span class="line">trying to forget but I won&apos;t let go </span><br><span class="line">looking at a crowded street </span><br><span class="line">listening to my own heart beat </span><br><span class="line">so many people all around the world </span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>晚饭的时候，当餐厅缓缓响起这首《take me to your heart》. 随着这首美妙的歌曲渐入高潮，我随之吟唱起来，也勾起了一段高中时代的小回忆，同时向朋友述说着…</p><p>2004年，还是在高一的时候，当Michael Learns to Rock发行《take me to your heart》这首歌曲，我们的英语老师觉得很好听，把歌词抄给我们记下，每到英语课，都会花几分钟，用磁带播放机一句一句播放，一句一句的教给我们，那个时候也是上英语课最开心的时刻，很快我们就会了，至今都能唱起。</p><p>开心时光并没有延续太长时间，不久，英语老师被诊断出了胃癌晚期。</p><p>然后英语老师缺席了我们后面的课程。</p><p>学校发动了募捐，我们也经常组织探望老师，但这并没有改变什么。</p><p>同学期，英语老师最终还是未能战胜病魔。《take me to your heart》也成了我们对老师最后的回忆。</p><p>我想，如果放在现在，如果能早点发现，那并没有那么多如果。对于不可逆的事情，你唯一能做也许就是令自己不要忘记。</p><p>过去10多年，这首歌但一直记忆深刻，《take me to your heart》也成了我最拿手的英文歌曲。</p><p>我想，这也是我记忆最深的一首歌。</p><hr><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="420" height="86" src="http://music.163.com/outchain/player?type=2&id=4173190&auto=1&height=66"></iframe><hr><blockquote><p>《take me to your heart》是迈克学摇滚（Michael Learns to Rock）主唱的一首歌，此歌曲翻唱自张学友的《吻别》。收录于专辑《Take Me to Your Heart》，2004年发行。</p><p> 迈克学摇滚（Michael Learns To Rock），始建于1987年，曾被形容是斯堪的纳维亚音乐传统与西洋流行音乐的相遇，绝非「丹麦团」三个字就可以解释。他们全球千万张惊人的销售量是一般乐团少有的，迈克学摇滚深入慢摇音乐情感层面并从中精确掌握音符组构成果的能力，使得他们成为丹麦音乐史上最成功的团体之一。迈克学摇滚在家乡已经有超过五十万张唱片的销售，但更惊人的是他们在全球的销售数字更是高达千万张之高！其中在亚洲更是掀起一阵狂潮。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="观点感悟" scheme="https://infullstack.github.io/categories/%E8%A7%82%E7%82%B9%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="歌" scheme="https://infullstack.github.io/tags/%E6%AD%8C/"/>
    
  </entry>
  
</feed>
